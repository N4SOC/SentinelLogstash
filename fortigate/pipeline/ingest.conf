input {
  tcp {
    port => 514
    type => syslog
    codec => cef {
      delimiter => "\n"
    }
  }
}
filter {
  if ("server-rst" in [name] or "client-rst" in [name] or "traffic close" in [name] or "traffic timeout" in [name]) {
    drop {
    }
  }

  if ([applicationProtocol]=="DNS" or [applicationProtocol]=="NTP" or [applicationProtocol]=="PING" or [applicationProtocol]=="SYSLOG" or [applicationProtocol]=="SNMP") {
    drop {
    }
  }

  if ([destinationAddress]=="10.200.105.22" and [destinationPort]=="10000") {
    drop {
    }
  }

  if ([destinationPort]=="2379") { # Kubernetes
    drop {
    }
  }

  if [sourceAddress] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ {
    cidr {
      add_tag => [ "priv_src" ]
      address => [ "%{sourceAddress}" ]
      network => [ "10.0.0.0/8","192.168.0.0/16","172.16.0.0/12","127.0.0.0/8","169.254.0.0/16","0.0.0.0/32","255.255.255.255/32" ]
    }
  }

  if [destinationAddress] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ {
    cidr {
      add_tag => [ "priv_dst" ]
      address => [ "%{destinationAddress}" ]
      network => [ "10.0.0.0/8","192.168.0.0/16","172.16.0.0/12","127.0.0.0/8","169.254.0.0/16", "0.0.0.0/32","255.255.255.255/32"]
    }
  }

  if "priv_src" not in [tags] {
    geoip {
      source => "sourceAddress"
      target => "geoip"
      add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
      add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
    }
      memcached {
                                        hosts => ["forti_memcached:11211"]
                                        namespace => "abuseipdb"
                                        get => {
                                        "%{[sourceAddress]}" => "[abuseipdb]"
                                        }
                                        add_tag => ["abuseipdb_from_cache"]
                                        id => "memcached-abuseipdb-get"
                        }
        }
                if ! [abuseipdb] and [sourceAddress] {
                if "." in [sourceAddress] or ":" in [src_ip] {
                http {
                        id => "abuseipdb-http-01"
                        url => "https://api.abuseipdb.com/api/v2/check?ipAddress=%{[src_ip]}"
                        #url => "https://api.abuseipdb.com/api/v2/check"
                        #query => { "ipAddress" => "[src_ip]" }
                        verb => "GET"
                        connect_timeout => 15
                        headers => { "Accept" => "application/json" "Key" => "<abuseipdb_key>" }
                        target_body => "[abuseipdb]"
                        target_headers => "[@metadata][abuseipdb_response_headers]"
                }
                if [abuseipdb] {
                        mutate { convert => { "[abuseipdb]" => "string" } }
                        memcached {
                                hosts => ["forti_memcached:11211"]
                                namespace => "abuseipdb"
                                set => {
                                "[abuseipdb]" => "%{[sourceAddress]}"
                                }
                                ttl => 7200
                                add_tag => ["abuseipdb_cached"]
                                id => "memcached-abuseipdb-set"
                        }
                }
                }
        }
        if [abuseipdb] {
                mutate { convert => { "[abuseipdb]" => "string" } }
        }
  

  if "priv_dst" not in [tags] {
    geoip {
      source => "destinationAddress"
      target => "geoip"
      add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
      add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
    }
  }

  mutate {
    convert => [ "[geoip][coordinates]", "float" ]
  }

}


output {
  pipeline {
    send_to => ["sentinel"]
  }
}

